System.register([],function(_){"use strict";return{execute:function(){_("atom",J);let I=0;function J(t,r){const i=`atom${++I}`,d={toString:()=>i};return typeof t=="function"?d.read=t:(d.init=t,d.read=L,d.write=N),r&&(d.write=r),d}function L(t){return t(this)}function N(t,r,i){return r(this,typeof i=="function"?i(t(this)):i)}const C=(t,r)=>t.unstable_is?t.unstable_is(r):r===t,V=t=>"init"in t,F=t=>!!t.write,E=()=>[new Set,new Set],z=(t,r)=>{(t[0]||t[1]).add(r)},p=(t,r)=>{let i;if(r){if(t[0])return;i=t[1]}else{if(!t[0])throw new Error("[Bug] cannot sync flush twice");i=t[0]}const d=new Set;for(;i.size;){const u=new Set(i);i.clear(),u.forEach(S=>{if(typeof S=="function")S();else{const[j,g]=S;!d.has(j)&&g.m&&(g.m.l.forEach(b=>b()),d.add(j))}})}return t[0]=void 0,d},M=Symbol(""),G="pending",R="fulfilled",T="rejected",U=t=>typeof t=="object"&&t!==null&&M in t,D=new WeakMap,$=(t,r,i)=>{if(!D.has(t)){let d;const u=new Promise((S,j)=>{let g=t;const b=w=>h=>{g===w&&(u.status=R,u.value=h,S(h),i())},k=w=>h=>{g===w&&(u.status=T,u.reason=h,j(h),i())};t.then(b(t),k(t)),d=(w,h)=>{w&&(D.set(w,u),g=w,w.then(b(w),k(w))),r(),r=h}});u.status=G,u[M]=d,D.set(t,u)}return D.get(t)},q=t=>typeof(t==null?void 0:t.then)=="function",P=t=>{var r;const i=(r=t.s)==null?void 0:r.v;return U(i)&&i.status===G?i:null},W=t=>{if("e"in t.s)throw t.s.e;return t.s.v},A=(t,r,i=()=>{},d=()=>{})=>{const u=P(t);if(q(r))if(u)u!==r&&u[M](r,i);else{const S=$(r,i,d);t.s={v:S}}else u&&u[M](Promise.resolve(r),i),t.s={v:r}},x=_("createStore",()=>{const t=new WeakMap,r=n=>{if(!t.has(n)){const s={d:new Map,t:new Set};t.set(n,s)}return t.get(n)},i=n=>{const s=r(n);for(const e of s.d.keys())r(e).t.delete(n);s.d.clear()},d=(n,s,e,a)=>{const f=r(n);if(f.d.set(s,e.s),e.t.add(n),!a&&f.m){const c=E();k(c,f),p(c)}},u=(n,s)=>{const e=r(n);if(!s&&"s"in e&&(e.m||Array.from(e.d).every(([o,m])=>{const y=u(o);return"v"in m&&"v"in y.s&&Object.is(m.v,y.s.v)})))return e;i(n);let a=!0;const f=o=>{if(C(n,o)){const y=r(o);if(!y.s)if(V(o))A(y,o.init);else throw new Error("no atom init");return W(y)}const m=u(o);return d(n,o,m,a),W(m)};let c,l;const v={get signal(){return c||(c=new AbortController),c.signal},get setSelf(){return!l&&F(n)&&(l=(...o)=>{if(!a)return b(n,...o)}),l}};try{const o=n.read(f,v);return A(e,o,()=>c==null?void 0:c.abort(),()=>{if(e.m){const m=E();k(m,e),p(m)}}),e}catch(o){return e.s={e:o},e}finally{a=!1}},S=n=>W(u(n)),j=(n,s)=>{const e=[],a=new Set,f=l=>{if(!a.has(l)){a.add(l);for(const v of r(l).t)l!==v&&f(v);e.push(l)}};f(s);const c=new Set([s]);for(let l=e.length-1;l>=0;--l){const v=e[l],o=r(v),m=o.s;let y=!1;for(const O of o.d.keys())if(O!==v&&c.has(O)){y=!0;break}y&&(o.m||P(o))&&(u(v,!0),k(n,o),(!m||!("v"in m)||!("v"in o.s)||!Object.is(m.v,o.s.v))&&(z(n,[v,o]),c.add(v)))}},g=(n,s,...e)=>{const a=c=>W(u(c)),f=(c,...l)=>{let v;if(C(s,c)){if(!V(c))throw new Error("atom not writable");const o=r(c),m=o.s,y=l[0];A(o,y),k(n,o);const O=o.s;(!m||!("v"in m)||!("v"in O)||!Object.is(m.v,O.v))&&(z(n,[c,o]),j(n,c))}else v=g(n,c,...l);return p(n,!0),v};return s.write(a,f,...e)},b=(n,...s)=>{const e=E(),a=g(e,n,...s);return p(e),a},k=(n,s)=>{if(s.m&&!P(s)){for(const e of s.d.keys())s.m.d.has(e)||(w(n,e),s.m.d.add(e));for(const e of s.m.d||[])s.d.has(e)||(h(n,e),s.m.d.delete(e))}},w=(n,s)=>{const e=r(s);if(!e.m){u(s);for(const a of e.d.keys())w(n,a);if(e.m={l:new Set,d:new Set(e.d.keys())},F(s)&&s.onMount){const a=e.m,{onMount:f}=s;z(n,()=>{const c=f((...l)=>g(n,s,...l));c&&(a.u=c)})}}return e.m},h=(n,s)=>{const e=r(s);if(e.m&&!e.m.l.size&&!Array.from(e.t).some(a=>r(a).m)){const a=e.m.u;a&&z(n,a),delete e.m;for(const c of e.d.keys())h(n,c);const f=P(e);f&&f[M](void 0,()=>{})}};return{get:S,set:b,sub:(n,s)=>{const e=E(),a=w(e,n);p(e);const f=a.l;return f.add(s),()=>{f.delete(s);const c=E();h(c,n),p(c)}}}});let B;const H=_("getDefaultStore",()=>(B||(B=x()),B))}}});
